.. _keyword table:
.. _user keyword:
.. _user keywords:
.. _higher-level keywords:
.. _Creating user keywords:

ユーザキーワードを定義する
========================

既存のキーワードを組み合わせて新しく高水準のキーワードを作るには、キーワードテーブルを使います。
新しく定義したキーワードは、テストライブラリの中で定義している、より低水準の *ライブラリキーワード* と区別するため、  *ユーザキーワード* と呼びます。
ユーザキーワードの作り方は、テストケースの作り方と非常によく似ているので、簡単に覚えられます。

.. contents::
   :depth: 2
   :local:

.. _User keyword syntax:

ユーザキーワードの構文
----------------------

.. _Basic syntax:

基本の構文
~~~~~~~~~~~~

多くの部分で、ユーザキーワードの基本的な構文は、 :ref:`テストケースの構文 <test case syntax>` と同じです。
ユーザキーワードはキーワードテーブルの中で定義します。テストケースはテストケーステーブルの中で定義し、二つを区別するのはテーブルの名前だけです。
ユーザキーワードの名前は、テストケースの名前と同じく、最初のカラムに書きます。
また、ユーザーキーワードも、テストケースと同じく、ライブラリ中のキーワードや他のユーザキーワードを組み合わせて定義します。
ユーザキーワードを構成するキーワードは、通常は2カラム目に書きます。例外は、変数にキーワードをセットするときで、その場合は3カラム目以降に書きます。

.. sourcecode:: robotframework

   *** Keywords ***
   Open Login Page
       Open Browser    http://host/login.html
       Title Should Be    Login Page

   Title Should Start With
       [Arguments]    ${expected}
       ${title} =    Get Title
       Should Start With    ${title}    ${expected}

たいていのユーザキーワードには、引数があります。
上の二つ目の例で、この重要な機能を使っています。
詳しくは :ref:`この後の節  ＜User keyword arguments>` で説明します。
:ref:`ユーザキーワードから値を返す <user keyword return values` 機能も同様です。

ユーザキーワードは、 :ref:`テストケースファイル <test case files>`, :ref:`リソースファイル<resource files>`, :ref:`テストスイート初期化ファイル <test suite initialization files>` で定義できます。
リソースファイルで定義したキーワードは、リソースファイルを取り込んだ別のファイルでも使えるようになります。
その他のファイルで定義したキーワードは、そのファイルの中でしか使えません。

.. _Settings in the Keyword table:

キーワードテーブル内で使える設定
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ユーザキーワードは、 :ref:`テストケースの設定 <Settings in the test case table>` と似た設定を持たせられます。設定は、テストケースの場合と同様、角カッコを使った構文を使って、キーワードと区別します。
使える設定は以下に挙げた通りで、それぞれの設定についてはこの後の節で解説します。

`[Documentation]`:setting:
   :ref:`ユーザキーワードのドキュメント <user keyword documentation>` の設定に使います。

`[Tags]`:setting:
   キーワードの :ref:`タグ <User keyword tags>` の設定に使います。

`[Arguments]`:setting:
   :ref:`ユーザキーワードの引数 <user keyword arguments>` の設定に使います。

`[Return]`:setting:
   :ref:`ユーザキーワードの戻り値 <user keyword return values>` の設定に使います。

`[Teardown]`:setting:
   :ref:`ユーザキーワードのティアダウン <user keyword teardown>` の設定に使います。

`[Timeout]`:setting:
   :ref:`ユーザキーワードのタイムアウト <user keyword timeout>` の設定に使います。
   :ref:`タイムアウト <Timeouts>` については、別の節で解説しています。


.. _User keyword documentation:

User keyword name and documentation
-----------------------------------

The user keyword name is defined in the first column of the user
keyword table. Of course, the name should be descriptive, and it is
acceptable to have quite long keyword names. Actually, when creating
use-case-like test cases, the highest-level keywords are often
formulated as sentences or even paragraphs.

User keywords can have a documentation that is set with the
:setting:`[Documentation]` setting, exactly as `test case documentation`_.
This setting documents the user keyword in the test data. It is also shown
in a more formal keyword documentation, which the Libdoc_ tool can create
from `resource files`_. Finally, the first row of the documentation is
shown as a keyword documentation in `test logs`_.

Sometimes keywords need to be removed, replaced with new ones, or
deprecated for other reasons.  User keywords can be marked deprecated
by starting the documentation with `*DEPRECATED*`, which will
cause a warning when the keyword is used. For more information, see
`Deprecating keywords`_ section.

User keyword tags
-----------------

Starting from Robot Framework 2.9, keywords can also have tags. User keywords
tags can be set with :setting:`[Tags]` setting similarly as `test case tags`_,
but possible :setting:`Force Tags` and :setting:`Default Tags` setting do not
affect them. Additionally keyword tags can be specified on the last line of
the documentation with `Tags:` prefix and separated by a comma. For example,
following two keywords would both get same three tags.

.. sourcecode:: robotframework

   *** Keywords ***
   Settings tags using separate setting
       [Tags]    my    fine    tags
       No Operation

   Settings tags using documentation
       [Documentation]    I have documentation. And my documentation has tags.
       ...                Tags: my, fine, tags
       No Operation


Keyword tags are shown in logs and in documentation generated by Libdoc_,
where the keywords can also be searched based on tags. The `--removekeywords`__
and `--flattenkeywords`__ commandline options also support selecting keywords by
tag, and new usages for keywords tags are possibly added in later releases.

Similarly as with `test case tags`_, user keyword tags with a `robot-` prefix
are reserved__ for special features by Robot Framework itself. Users should
thus not use any tag with a `robot-` prefix unless actually activating
the special functionality.

__ `Removing keywords`_
__ `Flattening keywords`_
__ `Reserved tags`_

User keyword arguments
----------------------

Most user keywords need to take some arguments. The syntax for
specifying them is probably the most complicated feature normally
needed with Robot Framework, but even that is relatively easy,
particularly in most common cases. Arguments are normally specified with
the :setting:`[Arguments]` setting, and argument names use the same
syntax as variables_, for example `${arg}`.

Positional arguments
~~~~~~~~~~~~~~~~~~~~

The simplest way to specify arguments (apart from not having them at all)
is using only positional arguments. In most cases, this is all
that is needed.

The syntax is such that first the :setting:`[Arguments]` setting is
given and then argument names are defined in the subsequent
cells. Each argument is in its own cell, using the same syntax as with
variables. The keyword must be used with as many arguments as there
are argument names in its signature. The actual argument names do not
matter to the framework, but from users' perspective they should
be as descriptive as possible. It is recommended
to use lower-case letters in variable names, either as
`${my_arg}`, `${my arg}` or `${myArg}`.

.. sourcecode:: robotframework

   *** Keywords ***
   One Argument
       [Arguments]    ${arg_name}
       Log    Got argument ${arg_name}

   Three Arguments
       [Arguments]    ${arg1}    ${arg2}    ${arg3}
       Log    1st argument: ${arg1}
       Log    2nd argument: ${arg2}
       Log    3rd argument: ${arg3}

Default values with user keywords
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When creating user keywords, positional arguments are sufficient in
most situations. It is, however, sometimes useful that keywords have
`default values`_ for some or all of their arguments. Also user keywords
support default values, and the needed new syntax does not add very much
to the already discussed basic syntax.

In short, default values are added to arguments, so that first there is
the equals sign (`=`) and then the value, for example `${arg}=default`.
There can be many arguments with defaults, but they all must be given after
the normal positional arguments. The default value can contain a variable_
created on `test, suite or global scope`__, but local variables of the keyword
executor cannot be used. Starting from Robot Framework 3.0, default value can
also be defined based on earlier arguments accepted by the keyword.

.. note:: The syntax for default values is space sensitive. Spaces
          before the `=` sign are not allowed, and possible spaces
          after it are considered part of the default value itself.

.. sourcecode:: robotframework

   *** Keywords ***
   One Argument With Default Value
       [Arguments]    ${arg}=default value
       [Documentation]    This keyword takes 0-1 arguments
       Log    Got argument ${arg}

   Two Arguments With Defaults
       [Arguments]    ${arg1}=default 1    ${arg2}=${VARIABLE}
       [Documentation]    This keyword takes 0-2 arguments
       Log    1st argument ${arg1}
       Log    2nd argument ${arg2}

   One Required And One With Default
       [Arguments]    ${required}    ${optional}=default
       [Documentation]    This keyword takes 1-2 arguments
       Log    Required: ${required}
       Log    Optional: ${optional}

    Default Based On Earlier Argument
       [Arguments]    ${a}    ${b}=${a}    ${c}=${a} and ${b}
       Should Be Equal    ${a}    ${b}
       Should Be Equal    ${c}    ${a} and ${b}

When a keyword accepts several arguments with default values and only
some of them needs to be overridden, it is often handy to use the
`named arguments`_ syntax. When this syntax is used with user
keywords, the arguments are specified without the `${}`
decoration. For example, the second keyword above could be used like
below and `${arg1}` would still get its default value.

.. sourcecode:: robotframework

   *** Test Cases ***
   Example
       Two Arguments With Defaults    arg2=new value

As all Pythonistas must have already noticed, the syntax for
specifying default arguments is heavily inspired by Python syntax for
function default values.

__ `Variable priorities and scopes`_

Varargs with user keywords
~~~~~~~~~~~~~~~~~~~~~~~~~~

Sometimes even default values are not enough and there is a need
for a keyword accepting `variable number of arguments`_. User keywords
support also this feature. All that is needed is having `list variable`_ such
as `@{varargs}` after possible positional arguments in the keyword signature.
This syntax can be combined with the previously described default values, and
at the end the list variable gets all the leftover arguments that do not match
other arguments. The list variable can thus have any number of items, even zero.

.. sourcecode:: robotframework

   *** Keywords ***
   Any Number Of Arguments
       [Arguments]    @{varargs}
       Log Many    @{varargs}

   One Or More Arguments
       [Arguments]    ${required}    @{rest}
       Log Many    ${required}    @{rest}

   Required, Default, Varargs
       [Arguments]    ${req}    ${opt}=42    @{others}
       Log    Required: ${req}
       Log    Optional: ${opt}
       Log    Others:
       : FOR    ${item}    IN    @{others}
       \    Log    ${item}

Notice that if the last keyword above is used with more than one
argument, the second argument `${opt}` always gets the given
value instead of the default value. This happens even if the given
value is empty. The last example also illustrates how a variable
number of arguments accepted by a user keyword can be used in a `for
loop`__. This combination of two rather advanced functions can
sometimes be very useful.

Again, Pythonistas probably notice that the variable number of
arguments syntax is very close to the one in Python.

__ `for loops`_

Kwargs with user keywords
~~~~~~~~~~~~~~~~~~~~~~~~~

User keywords can also accept `free keyword arguments`_ by having a `dictionary
variable`_ like `&{kwargs}` as the last argument after possible positional
arguments and varargs. When the keyword is called, this variable will get all
`named arguments`_ that do not match any positional argument in the keyword
signature.

.. sourcecode:: robotframework

   *** Keywords ***
   Kwargs Only
       [Arguments]    &{kwargs}
       Log    ${kwargs}
       Log Many    @{kwargs}

   Positional And Kwargs
       [Arguments]    ${required}    &{extra}
       Log Many    ${required}    @{extra}

   Run Program
       [Arguments]    @{varargs}    &{kwargs}
       Run Process    program.py    @{varargs}    &{kwargs}

The last example above shows how to create a wrapper keyword that
accepts any positional or named argument and passes them forward.
See `kwargs examples`_ for a full example with same keyword.

Also kwargs support with user keywords works very similarly as kwargs work
in Python. In the signature and also when passing arguments forward,
`&{kwargs}` is pretty much the same as Python's `**kwargs`.

.. _Embedded argument syntax:

Embedding arguments into keyword name
-------------------------------------

Robot Framework has also another approach to pass arguments to user
keywords than specifying them in cells after the keyword name as
explained in the previous section. This method is based on embedding
the arguments directly into the keyword name, and its main benefit is
making it easier to use real and clear sentences as keywords.

Basic syntax
~~~~~~~~~~~~

It has always been possible to use keywords like :name:`Select dog
from list` and :name:`Selects cat from list`, but all such keywords
must have been implemented separately. The idea of embedding arguments
into the keyword name is that all you need is a keyword with name like
:name:`Select ${animal} from list`.

.. sourcecode:: robotframework

   *** Keywords ***
   Select ${animal} from list
       Open Page    Pet Selection
       Select Item From List    animal_list    ${animal}

Keywords using embedded arguments cannot take any "normal" arguments
(specified with :setting:`[Arguments]` setting) but otherwise they are
created just like other user keywords. The arguments used in the name
will naturally be available inside the keyword and they have different
value depending on how the keyword is called. For example,
`${animal}` in the previous has value `dog` if the keyword
is used like :name:`Select dog from list`. Obviously it is not
mandatory to use all these arguments inside the keyword, and they can
thus be used as wildcards.

These kind of keywords are also used the same way as other keywords
except that spaces and underscores are not ignored in their
names. They are, however, case-insensitive like other keywords. For
example, the keyword in the example above could be used like
:name:`select x from list`, but not like :name:`Select x fromlist`.

Embedded arguments do not support default values or variable number of
arguments like normal arguments do. Using variables when
calling these keywords is possible but that can reduce readability.
Notice also that embedded arguments only work with user keywords.

Embedded arguments matching too much
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

One tricky part in using embedded arguments is making sure that the
values used when calling the keyword match the correct arguments. This
is a problem especially if there are multiple arguments and characters
separating them may also appear in the given values. For example,
keyword :name:`Select ${city} ${team}` does not work correctly if used
with city containing too parts like :name:`Select Los Angeles Lakers`.

An easy solution to this problem is quoting the arguments (e.g.
:name:`Select "${city}" "${team}"`) and using the keyword in quoted
format (e.g. :name:`Select "Los Angeles" "Lakers"`). This approach is
not enough to resolve all this kind of conflicts, though, but it is
still highly recommended because it makes arguments stand out from
rest of the keyword. A more powerful but also more complicated
solution, `using custom regular expressions`_ when defining variables,
is explained in the next section. Finally, if things get complicated,
it might be a better idea to use normal positional arguments instead.

The problem of arguments matching too much occurs often when creating
keywords that `ignore given/when/then/and/but prefixes`__ . For example,
:name:`${name} goes home` matches :name:`Given Janne goes home` so
that `${name}` gets value `Given Janne`. Quotes around the
argument, like in :name:`"${name}" goes home`, resolve this problem
easily.

__ `Ignoring Given/When/Then/And/But prefixes`_

Using custom regular expressions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When keywords with embedded arguments are called, the values are
matched internally using `regular expressions`__
(regexps for short). The default logic goes so that every argument in
the name is replaced with a pattern `.*?` that basically matches
any string. This logic works fairly well normally, but as just
discussed above, sometimes keywords `match more than
intended`__. Quoting or otherwise separating arguments from the other
text can help but, for example, the test below fails because keyword
:name:`I execute "ls" with "-lh"` matches both of the defined
keywords.

.. sourcecode:: robotframework

   *** Test Cases ***
   Example
       I execute "ls"
       I execute "ls" with "-lh"

   *** Keywords ***
   I execute "${cmd}"
       Run Process    ${cmd}    shell=True

   I execute "${cmd}" with "${opts}"
       Run Process    ${cmd} ${opts}    shell=True

A solution to this problem is using a custom regular expression that
makes sure that the keyword matches only what it should in that
particular context. To be able to use this feature, and to fully
understand the examples in this section, you need to understand at
least the basics of the regular expression syntax.

A custom embedded argument regular expression is defined after the
base name of the argument so that the argument and the regexp are
separated with a colon. For example, an argument that should match
only numbers can be defined like `${arg:\d+}`. Using custom
regular expressions is illustrated by the examples below.

.. sourcecode:: robotframework

   *** Test Cases ***
   Example
       I execute "ls"
       I execute "ls" with "-lh"
       I type 1 + 2
       I type 53 - 11
       Today is 2011-06-27

   *** Keywords ***
   I execute "${cmd:[^"]+}"
       Run Process    ${cmd}    shell=True

   I execute "${cmd}" with "${opts}"
       Run Process    ${cmd} ${opts}    shell=True

   I type ${a:\d+} ${operator:[+-]} ${b:\d+}
       Calculate    ${a}    ${operator}    ${b}

   Today is ${date:\d{4\}-\d{2\}-\d{2\}}
       Log    ${date}

In the above example keyword :name:`I execute "ls" with "-lh"` matches
only :name:`I execute "${cmd}" with "${opts}"`. That is guaranteed
because the custom regular expression `[^"]+` in :name:`I execute
"${cmd:[^"]}"` means that a matching argument cannot contain any
quotes. In this case there is no need to add custom regexps to the
other :name:`I execute` variant.

.. tip:: If you quote arguments, using regular expression `[^"]+`
         guarantees that the argument matches only until the first
         closing quote.

Supported regular expression syntax
'''''''''''''''''''''''''''''''''''

Being implemented with Python, Robot Framework naturally uses Python's
:name:`re` module that has pretty standard `regular expressions
syntax`__. This syntax is otherwise fully supported with embedded
arguments, but regexp extensions in format `(?...)` cannot be
used. Notice also that matching embedded arguments is done
case-insensitively. If the regular expression syntax is invalid,
creating the keyword fails with an error visible in `test execution
errors`__.

Escaping special characters
'''''''''''''''''''''''''''

There are some special characters that need to be escaped when used in
the custom embedded arguments regexp. First of all, possible closing
curly braces (`}`) in the pattern need to be escaped with a single backslash
(`\}`) because otherwise the argument would end already there. This is
illustrated in the previous example with keyword
:name:`Today is ${date:\\d{4\\}-\\d{2\\}-\\d{2\\}}`.

Backslash (:codesc:`\\`) is a special character in Python regular
expression syntax and thus needs to be escaped if you want to have a
literal backslash character. The safest escape sequence in this case
is four backslashes (`\\\\`) but, depending on the next
character, also two backslashes may be enough.

Notice also that keyword names and possible embedded arguments in them
should *not* be escaped using the normal `test data escaping
rules`__. This means that, for example, backslashes in expressions
like `${name:\w+}` should not be escaped.

Using variables with custom embedded argument regular expressions
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Whenever custom embedded argument regular expressions are used, Robot
Framework automatically enhances the specified regexps so that they
match variables in addition to the text matching the pattern. This
means that it is always possible to use variables with keywords having
embedded arguments. For example, the following test case would pass
using the keywords from the earlier example.

.. sourcecode:: robotframework

   *** Variables ***
   ${DATE}    2011-06-27

   *** Test Cases ***
   Example
       I type ${1} + ${2}
       Today is ${DATE}

A drawback of variables automatically matching custom regular
expressions is that it is possible that the value the keyword gets
does not actually match the specified regexp. For example, variable
`${DATE}` in the above example could contain any value and
:name:`Today is ${DATE}` would still match the same keyword.

__ http://en.wikipedia.org/wiki/Regular_expression
__ `Embedded arguments matching too much`_
__ https://docs.python.org/2/library/re.html
__ `Errors and warnings during execution`_
__ Escaping_

.. _Behavior-driven development example

ビヘイビアドリブンな開発の例
~~~~~~~~~~~~~~~~~~~~~~~~~~

キーワード名の中に変数を持てることの最大のメリットは、 :ref:`ビヘイビアドリブン型 <behavior-driven style>` のテストを書くときに、高水準の、文章として読めるキーワードを使いやすいことです。
以下に、その例を示しましょう。
この例では、 :name:`Given`, :name:`When`, :name:`Then` という接頭辞が、
:ref:`キーワードの定義では不要 <Ignoring Given/When/Then/And/But prefixes>` だということにも注意してください。

.. sourcecode:: robotframework

   *** Test Cases ***
   Add two numbers
       Given I have Calculator open
       When I add 2 and 40
       Then result should be 42

   Add negative numbers
       Given I have Calculator open
       When I add 1 and -2
       Then result should be -1

   *** Keywords ***
   I have ${program} open
       Start Program    ${program}

   I add ${number 1} and ${number 2}
       Input Number    ${number 1}
       Push Button     +
       Input Number    ${number 2}
       Push Button     =

   Result should be ${expected}
       ${result} =    Get Result
       Should Be Equal    ${result}    ${expected}

.. note:: Robot Framework の引数埋め込み機能は、有名な BDD ツール Cucumber__ の *ステップ定義 (step definition)* に着想を得ています。

__ http://cukes.info

.. _User keyword return values:

値を返すユーザキーワードを定義する
-------------------------------

ライブラリキーワードと同様、ユーザキーワードも値を返せます。
通常、戻り値は :setting:`[Return]` で設定できますが、 :ref:`BuiltIn` ライブラリのキーワード、 :name:`Return From Keyword` や :name:`Return From Keyword If` でも返せます。
どのやり方で返した戻り値も、テストケースや他のキーワードの中で、 :ref:`変数に代入<Return values from keywords>` して使えます。

.. _Using :setting:`[Return]` setting:

:setting:`[Return]` 設定の使い方
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ユーザキーワードの値の返し方のうちもっとも一般的なのは、ユーザキーワードが一つの値を返して、その値をスカラ値として代入する形式です。
:setting:`[Return]` 設定を使う場合は、設定名の次のセルに返したい値を入れます。

ユーザキーワードから複数の値を返すこともできます。その場合、複数のスカラ変数に一度に代入したり、リスト変数に代入したり、スカラ変数とリスト変数に組み合わせて代入したりできます。
複数の値を返したいときは、単に :setting:`[Return]` 設定の隣のセルに、返したい値を並べていくだけです。

.. sourcecode:: robotframework

   *** Test Cases ***
   One Return Value
       ${ret} =    Return One Value    argument
       Some Keyword    ${ret}

   Multiple Values
       ${a}    ${b}    ${c} =    Return Three Values
       @{list} =    Return Three Values
       ${scalar}    @{rest} =    Return Three Values

   *** Keywords ***
   Return One Value
       [Arguments]    ${arg}
       Do Something    ${arg}
       ${value} =    Get Some Value
       [Return]    ${value}

   Return Three Values
       [Return]    foo    bar    zap

.. _Using special keywords to return:

特別なキーワードを使って戻り値を制御する
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:ref:`BuiltIn` ライブラリのキーワード、 :name:`Return From Keyword` や :name:`Return From Keyword If` を使うと、条件に応じて、ユーザキーワードの処理の途中で値を返せます。
これらのキーワードは、いずれも、戻り値をオプションの引数にもたせることができ、先の :setting:`[Return]` で返すのと同じように値を返せます。

以下の例のうち、最初のものは、前節の :setting:`[Return]` を使った例と全く同じです。
二つ目の例は、ちょっと高度なことをやっていて、 :ref:`for ループ <for loop>` の中から値を返しています。

.. sourcecode:: robotframework

   *** Test Cases ***
   One Return Value
       ${ret} =    Return One Value  argument
       Some Keyword    ${ret}

   Advanced
       @{list} =    Create List    foo    baz
       ${index} =    Find Index    baz    @{list}
       Should Be Equal    ${index}    ${1}
       ${index} =    Find Index    non existing    @{list}
       Should Be Equal    ${index}    ${-1}

   *** Keywords ***
   Return One Value
       [Arguments]    ${arg}
       Do Something    ${arg}
       ${value} =    Get Some Value
       Return From Keyword    ${value}
       Fail    ここは実行されない

   Find Index
       [Arguments]    ${element}    @{items}
       ${index} =    Set Variable    ${0}
       :FOR    ${item}    IN    @{items}
       \    Return From Keyword If    '${item}' == '${element}'    ${index}
       \    ${index} =    Set Variable    ${index + 1}
       Return From Keyword    ${-1}    # [Return] を使っても書ける

.. note:: :name:`Return From Keyword` と :name:`Return From Keyword If` は、いずれも Robot Framework 2.8 から使えるようになりました。

.. _User keyword teardown:

ユーザキーワードのティアダウン
------------------------------

:setting:`[Teardown]` を使えば、ユーザーキーワードにティアダウン処理を定義できます。

キーワードのティアダウン処理は、 :ref:`テストケースのティアダウン <test setup and teardown>` と同じように働きます。
いちばん重要な類似点は、ティアダウンに設定できるのは単一のキーワードであり、他のユーザキーワードを指定でき、キーワードが失敗したときに実行されるということです。
さらに、ティアダウンに指定したキーワードの処理は、たとえその中で失敗が発生しても、全て実行されます。
ただし、ティアダウンキーワードの実行中に失敗が発生すると、そのテストケースは失敗し、残りのテストのステップは実行されません。ティアダウン用に実行するキーワードは、変数にもできます。

.. sourcecode:: robotframework

   *** Keywords ***
   With Teardown
       Do Something
       [Teardown]    Log    keyword teardown

   Using variables
       [Documentation]    Teardown given as variable
       Do Something
       [Teardown]    ${TEARDOWN}

